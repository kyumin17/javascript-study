# 20장 strict mode
### strict mode란?
```js
function foo() {
    x = 10;
}
```
- 암묵적 전역: foo 함수의 스코프에 x의 선언이 없으니 전역 스코프애서 x 변수를 찾고, 없으므로 x 프로퍼티를 동적으로 생성
- 이러한 오류 발생 가능성이 높거나 최적화에 문제를 일으킬 수 있는 코드에 명시적인 에러를 발생시킴
- 린트 도구 (ESLint)
    - strict mode가 제한하는 오류 잡음
    - 코딩 컨벤션 정의 및 강제 가능

### strict mode의 적용
- 전역 선두 혹은 몸체 선두에 'use strict;' 추가
- 전역에 strict mode 사용 피할 것
    - 스크립트 단위로 적용되는데, strict와 non-strict가 혼용될 시 오류 발생 가능성 있음
    - 즉시 실행 함수로 감싸는 것을 추천
- 함수 단위에 strict mode 사용 피할 것
    - 혼용 위험
    - 번거로움
- 즉시 실행 함수로 감싼 스크립트 단위로 적용할 것

### strict mode가 발생시키는 에러
1. 암묵적 전역
2. ```delete```연산자로 변수, 함수, 매개변수 삭제
3. 매개변수 이름 중복
4. ```with```문 사용

### strict mode 적용에 의한 변화
1. 일반 함수의 this
- 일반 함수로 함수 호출하면 this에 undefined 바인딩
2. arguments 객체
- 매개변수에 전달된 인수 재할당하여 변경해도 arguments 객체에 반영 X

# 21장 빌트인 객체
### 객체의 분류
1. 표준 빌트인 객체
- ECMA Script 사양 안애서 정의됨
- 자바스크립트 실행 환경과 관계없이 사용 가능
- 전역 객체의 프로퍼티로 제공
- 별도의 선언 없이 항상 참조 가능함
2. 호스트 객체
- 자바스크립트 실행 환경에서 추가로 제공됨
- 브라우저 환경일 경우 DOM, BOM, Canvas, XMLHttpRequest, fetch 등의 클라이언트 사이드 Web API를 호스트 객체로 제공
3. 사용자 정의 객체
- 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체

### 표준 빌트인 객체
- 자바스크립트는 40여개의 표준 빌트인 객체를 제공
- Math, Reflect, JSON을 제외한 전부는 인스턴스를 생성할 수 있는 생성자 함수 객체임
- String, Number, Boolean, Function, Array, Date는 생성자 함수로 호출해 인스턴스 생성 가능
```js
const strObj = new String('Lee'); // obj
const date = new Date(); // obj
```
- 표준 빌트인 객체의 prototype 프로퍼티에 바인딩 된 객체는 다양한 빌트인 프로토타입 메서드를 제공

### 원시값과 래퍼 객체
- 원시값에 대해 마침표 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환
- 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라 함
- 래퍼 객체의 처리가 종료되면 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 됨
- 심벌 역시 래퍼 객체 생성
- null과 undefined는 래퍼 객체를 생성하지 않음

### 전역 객체
- 어떤 객체보다도 먼저 생성되고, 어떤 객체에도 속하지 않는 최상위 객체
- 브라우저의 경우 window, Node.js의 경우 global
- 표준 빌트인 객체, 호스트 객체, var로 선언한 전역 변수, 전역 함수를 프로퍼티로 가짐   
(let 혹은 const로 선언 시 보이지 않는 개념적인 블록 내에 존재)
- 참조 시 window 또는 global 생략 가능

### 빌트인 전역 프로퍼티
1. Infinity
- type은 number
2. NaN
- Not-a-Number, type은 number
3. undefined
- type은 undefined

### 빌트인 전역 함수
1. eval
- 문자열 코드를 평가해 값을 생성
- 속도도 느리고 보안에도 안 좋으니 쓰지 말 것
2. isFinite
- 유한수이면 true, 무한수이면 false
3. isNaN
4. ParseFloat
- 문자열 인수를 실수로 해석해 반환
5. parseInt
- 문자열 인수를 정수로 해석해 반환
- ```parseInt(str, n)```로 n진수로 반환 가능

### encodeURI / decodeURI
- URI(URL + URN)을 문자열로 전달받아 인코딩함 (혹은 반대)
- 인코딩: 이스케이프 처리 (어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환)
- 디코딩: 인코딩 된 URI를 받아 이스케이프 처리 이전으로 돌림

### encodeURIComponent / decodeURIComponent
- URI 구성 요소를 전달받아 인코딩하거나 디코딩 함

### 암묵적 전역
- 암묵적 전역으로 생성된 전역 객체는 변수 선언이 없으므로 변수가 아니며, 따라서 변수 호이스팅도 발생 X
- 프로퍼티일 뿐이므로 delete로 삭제 가능 (전역 변수는 삭제 불가)

# 22장 this
### this 키워드
- 자기 자신을 참조할 때 재귀적으로 하는 경우, 생성자 함수 방식으로 인스턴스를 생성하는 경우 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다는 문제가 있음
- 따라서 자신이 속한 객체 또는 생성할 인스턴스를 가리키는 this 제공
- 암묵적으로 생성
- 함수 호출 시 arguments 객체와 this가 암묵적으로 함수 내부에 전달
- this를 지역 변수처럼 사용 가능
- this 바인딩은 함수 호출 방식에 의해 동적으로 결정
- 메서드 내부에서는 호출한 객체를, 생성자 함수 내부에서는 생성자 함수가 생성할 인스턴스를 가리킴

### 함수 호출 방식과 this 바인딩
1. 일반 함수 호출
- 전역 객체가 바인딩
- strict mode의 경우 undefined 바인딩
- 중첩 함수, 콜백 함수 포함
2. 메서드 호출
- 메서드를 호출한 객체에 바인딩 (소유한 객체 X)
- 다른 객체의 프로퍼티에 할당하는 것으로 다른 객체의 메서드가 될 수도 있음
3. 생성자 함수 호출
- 생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스가 바인딩
4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출
- this로 사용할 객체와 인수 리스트를 인수로 전달받아 함수 호출
- apply와 call은 함수를 호출하나 bind는 호출 X, this 바인딩 교체된 함수 새롭게 생성해 반환

# 23장 실행 컨텍스트
### 소스코드의 타입
1. 전역 코드: 전역에 존재하는 소스코드, 전역에 정의된 함수 및 클래스의 내부 코드 포함 X
2. 함수 코드: 함수 내부에 존재하는 소스코드, 함수 내부에 중첩된 함수 및 클래스 등의 내부 코드 포함 X
3. eval 코드: 빌트인 전역 함수인 eval에 인자로 전달되어 실행되는 소스코드
4. 모듈 코드: 모듈 내부에 존재하는 소스코드, 모듈 내부의 함수 및 클래스 등의 내부 코드 포함 X

### 소스코드의 평가와 실행
1. 소스코드의 평가
- 실행 컨텍스트 생성
- 변수, 함수 등의 선언문 먼저 실행하여 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록
2. 소스코드의 실행
- 변수나 함수의 참조와 같은 소스코드 실행에 필요한 정보는 실행 컨텍스트가 관리하는 스코프에서 검색해 취득
- 소스코드의 실행 결과는 실행 컨텍스트가 관리하는 스코프에 등록
```js
var x; // 평가 (스코프에 등록 & 초기화)
x = 1; // 실행 (등록 확인 & 할당)
```
