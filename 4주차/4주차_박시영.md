# 4주차
## 16장 : 프로퍼티 어트리뷰트

내부 슬롯 / 내부 메서드 : 외부로 공개된 객체의 프로퍼티 X, 단 일부에 한해 접근 가능
아래가 그 예시:
```javascript
const o = {};
o.[[Prototype]] 
// SyntaxError, Prototype이라는 내부 슬롯 접근 불가
o.__proto__ // 간접적으로 접근할 수 있는 방법
```

### 데이터와 접근자 프로퍼티
- 데이터 프로퍼티
key와 value로 구성된 프로퍼티.
- 접근자 프로퍼티
value를 갖지 않는 프로퍼티. 
다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성됨.

### **프로퍼티 어트리뷰트** 
== 프로퍼티가 생성될 때 기본값으로 정의되는 것들.

#### 데이터 프로퍼티
데이터 프로퍼티의 어트리뷰트 목록은 다음과 같다:
- [[Value]]
    - key를 통해 value에 접근하면 반환되는 값.
    - key를 통해 변경하면 [[Value]]에 값을 재할당. 프로퍼티가 없다면 프로퍼티를 동적 생성하고 그 곳에 값을 할당한다.
- [[Writable]]
    - value의 변경 가능 여부를 나타내며 boolean형.
    - false일 경우 해당 프로퍼티는 [[Value]]를 변경할 수 없는 읽기 전용 프로퍼티가 된다.
- [[Enumerable]]
    - 프로퍼티의 열거 가능 여부를 나타내며 boolean형.
    - false일 경우 for문이나 Object.keys 메서드 등으로 열거할 수 없다.
- [[Configurable]]
    - 프로퍼티의 재정의 가능 여부를 나타내며 boolean형.
    - false일 경우 해당 프로퍼티의 삭제 / 어트리뷰트 값의 변경이 금지된다.
    - 단, [[Writable]]이 true라면 [[Value]]의 변경과 [[Writable]]을 false로 돌리는 것은 가능.

#### 접근자 프로퍼티
접근자 프로퍼티의 어트리뷰트 목록은 다음과 같다: 
- [[Get]]
    - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 **접근자 함수**.
    - 접근자 프로퍼티 key로 value에 접근 >> [[Get]]의 값, getter 함수 호출 >> 해당 값이 프로퍼티 값으로 반환
- [[Set]]
    - get과 동일
- [[Enumerable]]
    - 데이터 프로퍼티의 그것과 동일
- [[Configurable]]
    - 이하동문

 *접근자 함수 (getter/setter 함수)는 하나만 정의할 수도 있고 모두 정의할 수도 있다.*

(데이터 프로퍼티들은 Object.getOwnPropertyDescriptor(s) 메서드로 간접적 확인이 가능하다.)
```javascript
const person = {
name: 'Lee',
get theName(){
    return '${this.name}';
},
set theName(newName){
    this.name = newName;
}
};
person.age = 20;
person.theName = 'Kim';
// 이때는 setter 함수가 호출된다. name value가 'Kim'으로 수정.

console.log(person.theName);
// 'Kim'을 반환하고, 이때는 getter 함수가 호출된다.

console.log(Object.getOwnPropertyDescriptor(person, 'name'));

// {value: "Kim", writable: true, enumerable: true, configurable: true}

console.log(Object.getOwnPropertyDescriptors(person));

/* {
name: {value: "Kim", writable: true, enumerable: true, configurable: true}
age: {value: 20, writable: true, enumerable: true, configurable: true}
} */
```

### 프로퍼티 정의
: 새로운 프로퍼티를 추가하면서 그 어트리뷰트를 명시적으로 정의하거나, 기존의 어트리뷰트를 재정의하는 것.
(Object.definePropert(y/ies) 메서드를 통해 어트리뷰트를 정의할 수 있다.)
``` javascript
const person = {};

Object.defineProperty(person, 'name',{
    value: 'Lee'.
    writable: true,
    enumerable: true,
    configurable: true
});
// 기본값은 undefined 혹은 false.
```

### 객체 변경 방지
객체는 변경 가능한 값, 따라서 재할당 없이 변경 가능.
그것을 방지하기 위한 메서드는 다음과 같다:

|구분|메서드|추가|삭제|값 읽기|값 쓰기|어트리뷰트 재정의|
|----|-------|-----|-----|-----|-----|--------|
|객체 확장 금지|Object.preventExtensions|x|o|o|o|o|
|객체 밀봉|Object.seal|x|x|o|o|x|
|객체 동결|Object.freeze|x|x|o|x|x|

*Object.isFrozen() 함수를 통해 프로퍼티의 동결 여부를 알 수 있다.*

그러나 Object.freeze는 직속 객체만 동결할 수 있고, 중첩 객체는 얼릴 수 없기 때문에 전부 동결시켜 읽기 전용의 **불변 객체**를 만들기 위해서는 해당 객체의 모든 프로퍼티에 재귀적으로 freeze를 호출해야 한다.

## 17장 : 생성자 함수에 의한 객체 생성

### Object 생성자 함수
```javascript
const person = new Object();
// 빈 객체를 생성하여 반환한다.
```
Object 이외에도 js가 지원하는 내장 생성자 함수는 다음을 포함한다:
- String
- Number
- Boolean
- Function
- Array
- Date
- RegExp
- Promise

### 생성자 함수
객체 리터럴을 통해 객체를 생성하면 비슷한 구조의 객체를 다수 생성해야 할 때 비효율적인 상황이 발생한다. 따라서 생성자 함수를 사용해볼 수 있다.
```javascript
//생성자 함수
function Circle(radius){
    this.radius = radius;
    this.getDiameter = function(){
        return 2 * this.radius
    };
}

const circle1 = new Circle(5);
const circle2 = new Circle(10);
// 각각 다른 반지름의 circle 객체를 생성했다.
const circle3 = Circle(15);
// new가 붙지 않아 일반 함수로서 동작했다. 
console.log(radius); // 15
// 일반 함수로서 동작할 때의 this는 전역 객체를 가리킨다.
console.log(circle1);
// Circle {radius: 5, getDiameter: f}
```

**this는 자기 참조 변수지만, 함수 호출 방식에 따라 가리키는 값이 다르다.**
|호출 방식|this 바인딩|
|-------|---------|
|일반 함수|전역 객체|
|메서드|메서드를 호출한 객체|
|생성자 함수|생성자 함수가 (미래에) 생성할 인스턴스|

만약 this 이외의 객체를 명시적으로 반환시 return 문에 명시된 객체가 반환. 하지만 그 명시된 것이 원시 값일 경우 이를 무시하고 this 반환.

### 내부 메서드 [[Call]]과 [[Construct]]
함수 역시 객체이므로 일반 객체처럼 동작 가능. 단, 함수는 **호출**할 수 있다. 함수 객체만이 가지고 있는 것은:
내부 슬롯 - [[Environment]], [[FormalParameters]]
내부 메서드 - [[Call]] (가지고 있는 함수는 callable 함수라 칭함), [[Construct]] (가지고 있으면 constructor, 없으면 non-constructor 함수라 칭함)
이 때 함수는 전부 callable하다.
일반 함수로서 호출 시 [[Call]]이 호출되며, 생성자 함수로서 호출 시 (new를 붙이는) [[Construct]]가 호출되는 차이.

### new.target
생성자 함수를 일반 함수와 비교하기 위해 *첫 문자를 대문자로 기술하는* **파스칼 케이스 컨벤션**을 사용한다.
하지만 그럼에도 new 없이 생성자 함수를 호출할 수 있으므로 이 때 사용되는 것이 new.target

생성자 함수로써 호출된 함수 내부의 new.target은 자기 자신을 가리키지만, 일반 함수로써 호출된 내부에서는 undefined이다.

```javascript
function Circle(radius){
    if(!new.target){
        return new Circle(radius);
    }
}
```
이런 식으로 페일세이프식 코드 작성이 가능. (ES6도입, IE에서는 지원x)

대부분의 내장 생성자 함수는 new 연산자와 함께 호출되었는지 확인을 한다. >> Object, Function 생성자 함수의 경우 new 연산자 없이도 동일하게 동작하는 예시.

String, Number, Boolean은 대신 new 연산자가 없다면 문자열, 숫자, 불리언 값을 반환. >> 이것으로 데이터 타입을 변환한다.

## 18장 : 함수와 일급 객체
## 19장 : 프로토타입