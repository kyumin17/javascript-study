# 10장 객체 리터럴
### 객체란?
- 변경 가능한 값
- 프로퍼티: 키와 값으로 구성
- 메서드: 프로퍼티 값이 함수
- 인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체
- this: 객체 자신을 가리키는 참조변수
- 함수 역시 객체
- 식별자 네이밍 규칙을 따르는 경우 키에 따옴표 생략 가능
- 키는 문자열 혹은 심벌이 아닌 경우 암묵적 타입 변환을 통해 문자열로 변환
- ```delete``` 키워드를 사용하여 프로퍼티 삭제

### 프로퍼티 축약
- ES6에서 추가
```js
const obj = { x, y } // { x: x, y: y }
```

### 계산된 프로퍼티 이름
- 외부에서 프로퍼티 키 동적 생성
```js
const obj = {};
obj[a + b] = c;
```
- 내부 생성 (ES6 추가)
```js
const obj = {
    [a + b]: c
};
```

### 메서드 축약 표현
- 프로퍼티 값으로 함수 생성 시 ```function```키워드 생략 가능

# 11장 원시 값과 객체의 비교
- 객체 타입의 경우 참조 값이 저장
- 객체 값을 갖는 변수를 다른 변수에 할당하면 값이 아닌 참조가 전달

### 원시 값
- 원시 값은 한 번 생성된 이후 변경 불가
- 상수는 재할당이 금지된 변수
- 재할당 시 새로운 메모리 공간을 확보 -> 재할당한 값 저장 -> 참조하던 메모리 공간 주소 변경
- 불변성을 가지는 경우 재할당 이외에 변수 값 변경 불가

### 문자열과 불변성
- 자바스크립트에서 문자열은 원시 값
- 원시 값을 객체로 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환
- 재할당으로만 값 변경 가능
```js
let str = 'hello world';
str[0] = 'y' // 반영 X
```

### 값에 의한 전달
- 변수에 원시 값 할당 시 값이 복사되어 전달
- 엄밀하게는 메모리 주소를 전달하여 메모리 공간에 접근해 값 참조

### 객체
- 변경 가능한 값 (복사해서 생성할 시 비용이 많이 들고 성능이 저하되기 때문)
- 메모리 공간의 크기를 사전에 정해둘 수 없음
- 자바, c++ 등의 클래스 기반 객체지향 언어와 달리 클래스 없이 객체 생성이 가능
    - 사용에 편리
    - 생성과 접근에 비용 더 많이 듦
    - 히든 클래스 이용해 성능 보장
- 변수에 객체 할당 시 참조 값이 저장

### 얕은 복사와 깊은 복사
- 얕은 복사: 한 단계까지만 복사
```js
const obj = { x: { y : 1 } };
const c1 = { ...o };
console.log(c1 === o); // false
console.log(c1.x === o.x); // true
```
- 깊은 복사: 객체에 중첩되어 있는 객체까지 복사
```js
const obj = { x: { y : 1 } };
const _ = require('lodash');
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

### 참조에 의한 전달
- 이것 역시 값에 의한 전달임
- 전달한 값이 원시 값이냐 참조 값이냐의 차이

# 12장 함수
### 함수란
- 일련의 과정을 문으로 구현하고 코드 블럭으로 감싸서 하나의 실행 단위로 정의한 것
- 입력을 인수, 함수 내부로 입력을 전달받는 변수를 매개변수라 함

### 함수 리터럴
- 리터럴: 값을 생성하는 표기 방식
- 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자
- 함수 이름 생략 가능
- 함수는 객체임
    - 일반 객체와 달리 호출 가능하며 고유한 프로퍼티를 지님

### 함수 정의
- 함수 선언문
```js
function add(x, y) { return x + y; }
```
- 함수 표현식
```js
const add = function (x, y) { return x + y; }
```
- Function 생성자 함수
```js
const add = new Function('x', 'y', 'return x + y');
```
- 화살표 함수(ES6)
```js
const add = (x, y) => x + y;
```

### 기명 함수 리터럴의 중의성
- 아래 코드는 함수 선언문으로 해석될 수도 있고, 함수 리터럴 표현식으로 해석될 수도 있음
- 할당하려면 표현식인 문이어야하므로 문맥에 따라 함수 리터럴 표현식으로 해석됨
```js
const add = function add(x, y) {
    return x + y;
};

console.log(add(2, 5)); // 7
```
- 함수 선언문(표현식이 아닌 문)으로 해석되는 경우
```js
function foo() { console.log('foo'); }
foo(); // foo
```
- 함수 표현식(표현식인 문)으로 해석되는 경우
    - 그룹 연산자 안에 있으므로 표현식인 문으로 해석됨
    - 함수 리터럴에서 함수 이름은 몸체 내에서만 참조가 가능하므로 호출 시 오류가 뜸
```javascript
(function bar() { console.log('bar'); });
bar(); // Reference Error: bar is not defined
```

### 함수 선언문
- 함수 이름 생략 불가
- 함수 몸체 밖에서 함수 이름으로 호출 가능
    - 자바스크립트 엔진이 암묵적으로 식별자를 생성
    - 함수 선언문 해석해 함수 객체 생성
    - 함수 객체를 가리키는 식별자가 필요
    - 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하여 함수 객체를 할당

### 함수 표현식
- 함수 이름 생략하는 것이 일반적

### 함수 생성 시점과 함수 호이스팅
- 함수 선언문으로 정의한 경우 이전에 호출이 가능하지만 표현식으로 정의한 경우 이전에 호출 불가능
- 함수 선언문의 경우 런타임 이전에 함수 객체가 먼저 생성됨
- 함수 표현식의 경우 변수 호이스팅이 발생함
- 이러한 이유 때문에 함수 표현식을 더 선호하기도
```js
console.log(add(7, 2)); // 9
console.log(sub(7, 2)); // undefined

function add(x, y) { return x + y; }
var sub = function (x, y) { return x - y; };
```

### Function 생성자 함수
- 클로저를 생성하지 않음

### 화살표 함수
- 항상 익명 함수로 정의됨
- 생성자 함수로 사용 불가
- this 바인딩 방식의 차이
- prototype 프로퍼티가 없음
- arguments 객체를 생성하지 않음

### 함수 호출
- 매개변수 역시 undefined로 초기화되고 인수가 할당됨
- 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않음
- 매개변수의 기본값(ES6)
```js
function sum(x = 0, y = 0) {
    return x + y;
}
```

### 클린 코드
- 이상적인 함수는 한 가지 일만 하며 가급적 작게 만들어야 함
- 매개변수는 3개 이상 넘지 않는 것을 권장하며 넘을 시 객체로 전달하기
- 객체로 전달 시 부수 효과가 일어나는 단점 존재

### 반환문
- 반환문 생략 시 암묵적으로 undefined 반환

### 참조에 의한 전달과 외부 상태의 변경
- 인수가 객체면 참조 값을 전달해서 값이 변경될 수 있음
- 객체를 불변 객체로 만들어 상태 변경을 원천봉쇄할 수 있음
- 혹은 객체를 깊은 복사하여 부수 효과를 없앨 수 있음

### 즉시 실행 함수
- 단 한 번만 호출되며 다시 호출할 수 없음
- 기명 함수 사용 가능하나 익명 함수가 일반적
- 함수는 함수 리터럴로 평가
- 변수나 함수 이름의 충돌을 방지
```js
(function (x, y) {
    return x + y;
})();
```

### 재귀 함수
- 재귀 함수를 이용하는 것이 직관적으로 이해하기 쉬울 때에만 사용하기

### 중첩 함수
```js
function outer() {
    let x = 1;
    function inner() {
        let y = 2;
        console.log(x + y); // 3
    }

    inner();
}

outer();
```

### 콜백 함수
- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
```js
function repeat(n, f) {
    for (let i = 0; i < n; i++) {
        f(i);
    }
}
```
- 고차함수: 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
- 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있음
- 고차 함수에 콜백 함수 전달 시 함수 자체를 전달해야 함
- 콜백 함수가 고차 함수 내부에서만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하는 것이 일반적임
    - 콜백 함수로 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체 생성
    - 함수가 자주 호출된다면 정의 후 참조를 전달하는 것이 효율적임
```js
repeat(100, function (i) { console.log(i) }); // repeat마다 함수 객체 생성

const print = function (i) { console.log(i) };
repeat(100, print); // 함수 한 번만 실행됨
```
- 비동기 처리 뿐 아니라 배열 고차 함수에서도 사용 ex) map, filter, reduce

### 순수 함수와 비순수 함수
- 순수 함수: 부수 효과 X
    - 동일한 인수가 전달되면 언제나 동일한 값을 반환
    - 인수를 변경하지 않음
    - 외부 상태에 의존하지 않고, 외부 상태를 바꾸지 않음
```js
function increase(n) {
    return ++n;
}
```
- 비순수 함수: 부수 효과 O
    - 외부 상태에 의존하거나 외부 상태를 변경
    - 최대한 쓰지 말자

# 스코프
### 스코프란
- 식별자가 유효한 범위
- 스코프가 있기에 같은 이름을 갖는 변수가 충돌을 일으키지 않을 수 있음

### 식별자 결정
- 같은 이름을 가지는 변수가 있을 때 어떤 변수를 참조할지 결정하는 것

### 스코프의 종류
- 전역: 코드의 가장 바깥 영역
- 지역: 함수 몸체 내부

### 스코프 체인
- 스코프가 계층적으로 연결된 것
- 변수 참조 시 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프 방향으로 이동하며 선언된 변수를 검색함
- 런타임 이전에 렉시컬 환경에 식별자가 키로 등록되고 변수 할당이 일어나면 해당 값을 변경
- 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것
- 함수 역시 스코프를 가짐

### 함수 레벨 스코프
- 코드 블럭이 아닌 함수에 의해서만 지역 스코프가 생성 (C, JAVA 등과 구별됨)

### 렉시컬 스코프
- 함수를 어디서 호출했는지가 아닌 어디서 정의했는지에 따라 상위 스코프를 결정
- 함수의 상위 스코프가 정적으로 결정됨
- 함수 객체는 상위 스코프를 기억하여 호출될 때마다 참조함

# 전역 변수의 문제점
### 변수의 생명 주기
- 메모리 공간이 확보된 시점부터 해제되어 가용 메모리 풀에 반환되는 시점까지
- 지역 변수의 생명 주기는 함수의 생명 주기와 일치함
- 변수는 자신이 등록된 스코프가 소멸될 때까지 유효함
- 할당된 메모리 공간은 누구도 참조하지 않을 때 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환됨
- 스코프 역시 누군가 참조하고 있으면 소멸하지 않음
- 호이스팅은 스코프를 단위로 동작

### 전역 변수의 생명 주기
- 전역 객체의 생명 주기와 일치
- 브라우저 환경에서 전역 객체는 웹페이지를 닫기 전까지 유효함

### 전역 변수의 문제점
- 암묵적 결합(모든 코드가 전역 변수를 참조 및 변경할 수 있음)을 허용
- 긴 생명주기
- 전역 변수의 검색 속도가 가장 느림
- 네임스페이스 오염
    - 자바스크립트는 파일이 분리되어 있더라도 하나의 전역 스코프를 공유함
    - 다른 파일 내에 동일한 이름의 변수 있으면 예상치 못한 결과를 초래

### 전역 변수의 사용을 억제하는 방법
- 변수의 스코프는 좁을 수록 좋음
- 즉시 실행 함수
    - 라이브러리 등에 자주 사용됨
- 모듈 패턴
```js
let Counter = (function () {
    let num = 0; // private

    return {
        increase() {
            return ++num;
        },
        decrease() {
            return --num;
        }
    };
}());

console.log(Counter.num); // undefined
console.log(Counter.increase()); // 1
console.log(Counter.decrease()); // 0
```
- ES6 모듈
    - ```type="module"```로 자바스크립트 코드를 불러옴
    - 전역 변수 사용이 불가함
    - 구형 브라우저에서 동작하지 않음

# let, const 키워드와 블록 레벨 스코프
### var 키워드로 선언한 변수의 문제점
- 변수 중복 선언 허용
- 함수 레벨 스코프
- 변수 호이스팅

### let 키워드
- 변수 중복 선언 금지
- 블록 레벨 스코프
- 초기화가 런타임에 이루어져 TDZ(일시적 사각지대)가 생김
- var로 생성된 변수가 window 객체의 프로퍼티가 되며 window는 생략 가능함
- let으로 생성된 변수는 전역 객체의 프로퍼티가 아니며, 개념적인 블록 내에 존재하게 됨

### const 키워드
- 선언과 초기화: const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화헤야 함
- 재할당 금지
- 대문자로 선언하며 스네이크 케이스로 나타내는 것이 일반적
- 불변을 의미하지는 않음

# ✨토론 주제
### 객체 지향 프로그래밍과 함수형 프로그래밍
**객체 지향 프로그래밍**
1. 추상화
- 공통적인 속성이나 기능을 묶어서 이름을 붙임
2. 캡슐화
- 데이터를 은닉하고 데이터 기능을 노출시키지 않음
3. 상속성
- 상위 부모 객체의 속성과 특징을 하위 객체가 물려 받음
4. 다형성
- 같은 함수가 있어도 매개변수에 따라 각자 다른 일을 함

특징
- 코드의 재사용이 가능하나 처리 속도가 느리고 설계에 시간이 많이 걸림
- 클래스가 일급 객체가 됨

**함수형 프로그래밍**   
순수 함수를 이용해 불변성을 유지함

특징
- 가독성이 좋음
- 함수가 일급 객체가 됨

**참고**   
https://velog.io/@majaeh43/%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D
