# 3주차
### 10장 객체 리터럴   

프로퍼티: 객체의 상태를 나타내는 값 (프로퍼티 키 *문자열, 심볼/ 프로퍼티 값)   
*프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않을 경우, 반드시  '', " " 사용   
*프로퍼티 나열 시 쉼표 사용   

매서드: 프로퍼티를 '참조'하고 '조작'할 수 있는 동작   
객체 리터럴: 객체를 생성하기 위해 문자 또는 기호를 사용하는 것.

*프로퍼티 키의 동적 생성*   
프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 함.    

     var obj = {};
     var key = 'hello'; // 프로퍼티 키 <- 문자열
     obj[key] = 'world'; // 프로퍼티 키: 프로퍼티 값
     console.log(obj); // {hello: "world"} 

*메서드*    
.function: 프로퍼티 값이 함수 인 경우.

     var circle = {
        radius : 5,

        getDiameter: function(){
            return 2 * this.radius; // this => 객체 자신(circle)를 가리키는 참조변수
        }
     }

*프로퍼티 접근*

     var person = {
        name: 'Lee'
     };

     // 마침표 표기법
     console.log(person.name); // Lee
     // 대괄호 표기법 (대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 함)
     console.log(person['name']); // Lee

(+)   
1) 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됨.
2) 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고, 프로퍼티 값이 할당됨.
3) delete 연산자를 통해 객체의 프로퍼티 삭제 가능. 존재하지 않는 프로퍼티를 삭제하는 경우 에러 없이 무시.   

계산된 프로퍼티 이름   
객체 리터럴 외부에서 대괄호 기법 사용   

     var prefix = 'prop';
     var i = 0;

    var obj = {};
    obj[prefix + '-' + ++i] = i;
    obj[prefix + '-' + ++i] = i;

    console.log(obj); // {prop-1: 1, prop-2: 2}

객체 리터럴 내부에서 계산된 프로퍼티 ${} 이름

    const prefix = 'prop';
    let i = 0;

    const obj = {
      ['${prefix}-${++i}']: i,
      ['$[prefix]-${++i}']: i
    };
    console.log(obj); // {prop-1: 1. prop-2: 2}


### 11장 원시 값과 객체의 비교   

*원시 타입의 값 vs 객체 타입의 값*   

1) 원시 값: 변경 불가 / 객체 값: 변경 가능
2) 원시 값: 변수 할당 시 메모리에 실제 값 저장 / 객체 값: 변수 할당 시 메모리에 참조 값 저장
3) 원시 값: 다른 변수에도 할당 시 원시 값이 복사되어 전달(값에 의한 전달) / 객체 값: 다른 변수에도 할당 시 참조 값이 복사되어 전달(참조에 의한 전달)   

*유사 배열 객체*   
문자열 -> 유사 배열 객체이자 이터러블. (length 프로퍼티를 갖는 객체. string 객체로 처리함)

    var str = 'string';
    // 유사 배열 접근
    // str[0] = r 처럼 이미 생성된 문자열의 일부를 바꿀 순 없음. 변수에 값 재할당은 가능.
    console.log(str[0]); // s
    // 원시 값인 문자열이 객체처럼 작동
    console.log(str.length); // 6
    console.log(str.toUpperCase); // STRING


<객체를 프로퍼티 값으로 갖는 객체>   
얕은 복사: 한 단계까지만 복사 (참조 값 복사) or 객체를 할당한 변수를 다른 변수에 할당하는 것   
깊은 복사: 객체에 중첩되어 있는 객체까지 모두 복사(완전 복사) or 원시 값을 할당한 변수를 다른 변수에 할당하는 것   

    const o = {x : {y : 1}};
    // 얕은 복사
    const c1 = {...o};
    console.log(c1 === o); // false 
    console.log(c1.x === o.x); // true

    // 깊은 복사
    const _ = require('lodash');
    const c2 = _.cloneDeep(o);
    console.log(c2 === 0); // false
    console.log(c2.x === o.x); // false (c2는 o의 복사본)
 
*참조에 의한 전달*

    var person = {
        name: 'Lee'
    };
    var copy = person;
copy에는 person의 참조 값({name:'Lee'}가 저장되어 있는 주소 값)이 복사되어 저장된다. -> 두 개의 식별자 (copy, person)이 하나의 객체를 공유. 어느 한 쪽에서 객체를 변경하면 둘 다 영향 받음.


### 12장 함수   
함수 (매개변수parameter: 함수 내부로 입력을 받는 함수, 인수argument: 입력, 반환값return value: 출력)   

    function name(x,y){
        return x+y;
    } // 함수 정의, (x,y) -> 매개변수(parameter)
    name(2,5); // 함수 호출, (2,5) -> 인수(argument)

함수 호출 vs 함수 리터럴 할당

    //함수 호출 -> 함수에 인수 전달
    var result = name(2,5);
    console.log(result); // 7

    //함수 리터럴 할당
    var f = function name(x,y){
        return x+y;
    }; // 함수 이름 생략 가능

함수 정의

    // 함수 선언문
    function add(x,y){
        return x + y;
    }
    // 함수 표현식
    var add = function(x,y){
        return x + y;
    };
    // Function 생성자 함수
    var add = new Function('x', 'y', 'return x+y');
    // 화살표 함수
    var add = (x,y) => x + y;

*기명 함수 리터럴의 중의적 해석*   
함수 선언문 vs 함수 리터럴   
*그룹 연산자() 내에 있는 함수 리터럴은 함수 리터럴 표현식으로 해석됨   

    // 기명 함수 리터럴을 단독으로 사용할 경우, 함수 선언문으로 해석
    function foo(){console.log('foo');}
    foo(); // foo
    => 이때 'foo'는 '함수 이름(함수 몸체 내에서만 참조할 수 있는 식별자)'이지만, 함수 선언문이므로 'foo'식별자를 자바스크립트 엔진이 암묵적으로 생성하고 객체를 할당함. foo(); 를 통해 함수 선언문으로 생성한 함수를 호출한 것은 '함수 이름 foo'가 아니라 자바스크립트 엔진이 암묵적으로 생성한 '식별자 foo'인 것.


    //함수 리터럴을 피연산자로 사용할 경우, 함수 리터럴 표현식으로 해석됨
    (function bar(){console.log('bar');});
    bar(); // ReferenceError: bar is not defined
    => '함수 리터럴'에서 '함수 이름'은 '함수 몸체 내에서만 참조할 수 있는 식별자'. 함수 몸체 외부에서는 '함수 이름'으로 함수를 참조할 수 없으므로, '함수 이름'을 통해 함수를 호출할 수 없다. (함수를 가리키는 식별자가 없는 것과 마찬가지)


*함수 생성 시점과 함수 호이스팅*

    // 함수 호출문
    console.log(add(2,5)); // 7
    console.log(sub(2,5)); // TypeError: sub is not a function

    // 함수 선언문
    function add(x,y){
        return x + y;
    }
    // 함수 표현식
    var sub = function(x,y){
        return x - y;
    };

- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출 가능. (런타임 이전 생성)
- 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출 불가능. (런타임 이후 생성)
- 함수 호이스팅(함수 선언식): 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 함수 식별자가 생성된다. 이 함수 식별자에 함수 객체가 초기화되므로, 함수 선언문 이전에 함수를 호출할 수 있다.
- 변수 호이스팅(함수 표현식): 변수 선언은 런타임 이전에 실행. undefined로 초기화됨. 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가됨. 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 함수의 객체가 됨.   


>**함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수 효과가 발생한다**   
>
>왜? 객체는 참조 값(주소 값)이 복사되어 전달되므로..


*즉시 실행 함수*   
함수 정의와 동시에 즉시 호출되는 함수. 단 한 번만 호출되며 다시 호출 불가능.   
그룹 연산자()의 피연산자로 함수를 할당 (할당된 함수 -> 함수 리터럴로 평가됨)  

    // 익명 즉시 실행 함수
    (function(){
        var a = 3;
        var b = 5;
        return a * b;
    }());

    // 기명 즉시 실행 함수
    (function foo(){
        var a = 3;
        var b = 5;
        return a * b;
    }());

*재귀함수*   

    function countdown(n){
        if (n<0) return; // 탈출 조건
        console.log(n);
        countdown(n-1); // 재귀 호출
    }
    countdown(10); // 함수 호출

*중첩 함수*   
함수 내부에 정의된 함수   
*콜백 함수*   
어떤 일을 반복 수행하는 repeat 함수   




### 13장 스코프


### 14장 전역 변수의 문제점


### 15장 let, const 키워드와 블록 레벨 스코프






// ??   

함수 표현식 vs 함수 선언식   
*선언문은 표현식이 아닌 문. 따라서 변수에 할당할 수 없음.   
*함수 표현식은 얼핏 보면 함수 선언문이 변수에 할당되는 것처럼 보이지만 함수 리터럴이 할당된 것.   
*(함수 선언문은 함수 이름을 생랼할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일하긴 함)   
*함수 표현식은 ';' 필요. 함수 선언식은 '함수'에 종결의 의미가 있으므로 ';' 필요X   
